using System.Collections.Generic;
using System.Globalization;
using System.Text;
using Microsoft.CodeAnalysis;

namespace BenchmarkDotNet.ReportColumns;

internal static class SourceProductionContextExtensions
{
    public static void AddResults(this SourceProductionContext context, BenchmarkTypeSpec benchmark)
    {
        const string template =
        """
        // <auto-generated/>
        #nullable enable
        using System;
        using System.Collections.Generic;
        using System.Globalization;
        using System.Linq;
        using System.Text;
        using BenchmarkDotNet.Analysers;
        using BenchmarkDotNet.Columns;
        using BenchmarkDotNet.Configs;
        using BenchmarkDotNet.Diagnosers;
        using BenchmarkDotNet.Engines;
        using BenchmarkDotNet.Exporters;
        using BenchmarkDotNet.Loggers;
        using BenchmarkDotNet.Reports;
        using BenchmarkDotNet.Running;
        using BenchmarkDotNet.Validators;

        namespace {1}
        {{
            internal static class {0}
            {{
                private static readonly object Lock = new();
                private static readonly Dictionary<BenchmarkCase, Dictionary<string, string>> Results = new();

                public static void Store(BenchmarkCase benchmarkCase, string key, string value)
                {{
                    lock (Lock)
                    {{
                        if (!Results.TryGetValue(benchmarkCase, out var map))
                        {{
                            map = new Dictionary<string, string>(StringComparer.Ordinal);
                            Results[benchmarkCase] = map;
                        }}

                        map[key] = value;
                    }}
                }}

                public static string? Get(BenchmarkCase benchmarkCase, string key)
                {{
                    lock (Lock)
                    {{
                        if (!Results.TryGetValue(benchmarkCase, out var map))
                        {{
                            return null;
                        }}

                        return map.TryGetValue(key, out var value) ? value : null;
                    }}
                }}
            }}
        }}
        """;

        var sourceCode = string.Format(CultureInfo.InvariantCulture, template, benchmark.ResultsTypeName, benchmark.GeneratedNamespace);
        context.AddSource($"{benchmark.SafeBenchmarkTypeName}_Results.g.cs", sourceCode);
    }

    public static void AddAggregationHelpersSource(this SourceProductionContext context)
    {
        var sourceCode =
        """
        // <auto-generated/>
        #nullable enable
        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Globalization;
        using BenchmarkDotNet.Columns;
        using BenchmarkDotNet.Mathematics;

        namespace BenchmarkDotNet.ReportColumn.Generated
        {
            internal static class AggregationHelpers
            {
                public static string Aggregate<T>(BenchmarkDotNet.ReportColumns.Aggregation aggregation, List<T> samples) where T : notnull
                {
                    if (samples.Count == 0)
                    {
                        return string.Empty;
                    }

                    // Check if we can compute statistics using built-in Statistics class
                    Statistics? stats = samples switch
                    {
                        List<double> doubles => new Statistics(doubles),
                        List<float> floats => new Statistics(floats.Select(Convert.ToDouble)),
                        List<byte> bytes => new Statistics(bytes.Select(Convert.ToDouble)),
                        List<sbyte> sbytes => new Statistics(sbytes.Select(Convert.ToDouble)),
                        List<ushort> ushorts => new Statistics(ushorts.Select(Convert.ToDouble)),
                        List<short> shorts => new Statistics(shorts.Select(Convert.ToDouble)),
                        List<uint> uints => new Statistics(uints.Select(Convert.ToDouble)),
                        List<int> ints => new Statistics(ints.Select(Convert.ToDouble)),
                        List<System.TimeSpan> timespans => new Statistics(timespans.Select(t => t.TotalMilliseconds)),
                        _ => null
                    };

                    if (stats is not null)
                    {
                        double val = aggregation switch
                        {
                            BenchmarkDotNet.ReportColumns.Aggregation.First => stats.OriginalValues[0],
                            BenchmarkDotNet.ReportColumns.Aggregation.Last => stats.OriginalValues[^1],
                            BenchmarkDotNet.ReportColumns.Aggregation.Min => stats.Min,
                            BenchmarkDotNet.ReportColumns.Aggregation.Max => stats.Max,
                            BenchmarkDotNet.ReportColumns.Aggregation.Mean => stats.Mean,
                            BenchmarkDotNet.ReportColumns.Aggregation.Median => stats.Median,
                            _ => stats.OriginalValues[^1],
                        };

                        return val.ToString(CultureInfo.InvariantCulture);
                    }

                    // Fallback for other types
                    var value = aggregation switch
                    {
                        BenchmarkDotNet.ReportColumns.Aggregation.First => samples[0],
                        BenchmarkDotNet.ReportColumns.Aggregation.Last => samples[^1],
                        _ => samples[^1],
                    };

                    // Use invariant culture for formatting if possible (e.g. DateTime)
                    if (value is IFormattable formattable)
                    {
                        return formattable.ToString(null, CultureInfo.InvariantCulture);
                    }

                    return value.ToString() ?? string.Empty;
                }
            }
        }

        """;

        context.AddSource("AggregationHelpers.g.cs", sourceCode);
    }

    public static void AddInProcessDiagnoser(this SourceProductionContext context, BenchmarkTypeSpec benchmark)
    {
        var sourceTemplate =
        """
        // <auto-generated/>
        #nullable enable
        using System;
        using System.Collections.Generic;
        using System.Text.Json;
        using BenchmarkDotNet.Analysers;
        using BenchmarkDotNet.Diagnosers;
        using BenchmarkDotNet.Engines;
        using BenchmarkDotNet.Exporters;
        using BenchmarkDotNet.Loggers;
        using BenchmarkDotNet.Reports;
        using BenchmarkDotNet.Running;
        using BenchmarkDotNet.Validators;

        namespace {3}
        {{
            public sealed class {0} : IInProcessDiagnoser
            {{
                public IEnumerable<string> Ids => new[] {{ nameof({0}) }};
                public IEnumerable<IExporter> Exporters => Array.Empty<IExporter>();
                public IEnumerable<IAnalyser> Analysers => Array.Empty<IAnalyser>();
                public RunMode GetRunMode(BenchmarkCase benchmarkCase) => RunMode.NoOverhead;
                public void Handle(HostSignal signal, DiagnoserActionParameters parameters) {{ }}
                public void DisplayResults(ILogger logger) {{ }}
                public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) => Array.Empty<ValidationError>();

                public InProcessDiagnoserHandlerData GetHandlerData(BenchmarkCase benchmarkCase)
                {{
                    return new InProcessDiagnoserHandlerData(typeof({1}), serializedConfig: null);
                }}

                public void DeserializeResults(BenchmarkCase benchmarkCase, string serializedResults)
                {{
                    var map = JsonSerializer.Deserialize<Dictionary<string, string>>(serializedResults);

                    if (map is null)
                    {{
                        return;
                    }}

                    foreach (var kvp in map)
                    {{
                        {2}.Store(benchmarkCase, kvp.Key, kvp.Value);
                    }}
                }}

                public IEnumerable<Metric> ProcessResults(DiagnoserResults results) => Array.Empty<Metric>();
            }}
        }}
        """;

        var source = string.Format(
            CultureInfo.InvariantCulture,
            sourceTemplate,
            benchmark.InProcessDiagnoserTypeName,
            benchmark.InProcessDiagnoserHandlerTypeName,
            benchmark.ResultsTypeName,
            benchmark.GeneratedNamespace);

        context.AddSource($"{benchmark.SafeBenchmarkTypeName}_InProcessDiagnoser.g.cs", source);
    }

    public static void AddInProcessDiagnoserHandler(this SourceProductionContext context, BenchmarkTypeSpec benchmark, List<ReportColumnPropertySpec> columns)
    {
        const string fieldTemplate = "private readonly List<{0}> {1} = new();";
        const string addMeasurementTemplate = "{1}.Add(benchmark.{0});";
        const string serializeTemplate = @"map.Add(""{2}"", AggregationHelpers.Aggregate(BenchmarkDotNet.ReportColumns.Aggregation.{1}, {0}));";

        var fieldsBuilder = new StringBuilder();
        var addMeasurementsBuilder = new StringBuilder();
        var serializeBuilder = new StringBuilder();

        foreach (var col in columns)
        {
            fieldsBuilder.Append(' ', 8);
            fieldsBuilder.AppendFormat(
                CultureInfo.InvariantCulture,
                fieldTemplate,
                col.CSharpTypeName,
                col.ResultKey);
            fieldsBuilder.AppendLine();

            addMeasurementsBuilder.Append(' ', 12);
            addMeasurementsBuilder.AppendFormat(
                CultureInfo.InvariantCulture,
                addMeasurementTemplate,
                col.PropertyName,
                col.ResultKey);
            addMeasurementsBuilder.AppendLine();

            serializeBuilder.Append(' ', 12);
            serializeBuilder.AppendFormat(
                CultureInfo.InvariantCulture,
                serializeTemplate,
                col.ResultKey,
                col.Aggregation,
                col.ResultKey);
            serializeBuilder.AppendLine();
        }

        var sourceTemplate =
        """
        // <auto-generated/>
        #nullable enable
        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Text.Json;
        using BenchmarkDotNet.Columns;
        using BenchmarkDotNet.Diagnosers;
        using BenchmarkDotNet.Engines;
        using BenchmarkDotNet.ReportColumn.Generated;
        using {0};

        namespace {6}
        {{
            public sealed class {1} : IInProcessDiagnoserHandler
            {{

        {3}

                public void Initialize(string? serializedConfig) {{ }}

                public void Handle(BenchmarkSignal signal, InProcessDiagnoserActionArgs args)
                {{
                    if (signal != BenchmarkSignal.AfterActualRun)
                    {{
                        return;
                    }}

                    if (args.BenchmarkInstance is not {2} benchmark)
                    {{
                        return;
                    }}

        {4}

                }}

                public string SerializeResults()
                {{
                    var map = new Dictionary<string, string>();

        {5}

                    return JsonSerializer.Serialize(map);
                }}
            }}  
        }}
        """;

        var sourceCode = string.Format(
            CultureInfo.InvariantCulture,
            sourceTemplate,
            benchmark.Namespace,
            benchmark.InProcessDiagnoserHandlerTypeName,
            benchmark.TypeName,
            fieldsBuilder,
            addMeasurementsBuilder,
            serializeBuilder,
            benchmark.GeneratedNamespace);

        context.AddSource($"{benchmark.SafeBenchmarkTypeName}_InProcessDiagnoserHandler.g.cs", sourceCode);
    }

    public static void AddColumns(this SourceProductionContext context, BenchmarkTypeSpec benchmark, List<ReportColumnPropertySpec> columns)
    {
        const string columnTemplate =
        """
            public sealed class {0} : IColumn
            {{
                public string Id => "{1}";
                public string ColumnName => "{2}";
                public string Legend => "{3}";
                public UnitType UnitType => UnitType.Dimensionless;
                public bool AlwaysShow => true;
                public ColumnCategory Category => ColumnCategory.Custom;
                public int PriorityInCategory => 0;
                public bool IsNumeric => {4};
                public bool IsAvailable(Summary summary) => true;
                public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) => false;

                public string GetValue(Summary summary, BenchmarkCase benchmarkCase)
                {{
                    return {5}.Get(benchmarkCase, "{1}") ?? "N/A";
                }}

                public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) => GetValue(summary, benchmarkCase);
            }}

        """;

        var columnsBuilder = new StringBuilder();

        foreach (var col in columns)
        {
            var columnTypeName = $"{col.SafeColumnTypeName}_Column";
            var legend = $"{col.Aggregation} {col.ColumnHeader}";
            var isNumeric = col.IsNumeric ? "true" : "false";

            columnsBuilder.AppendFormat(
                CultureInfo.InvariantCulture,
                columnTemplate,
                columnTypeName,
                col.ResultKey,
                col.ColumnHeader,
                legend,
                isNumeric,
                benchmark.ResultsTypeName);

            columnsBuilder.AppendLine();
        }

        var sourceTemplate =
        """
        // <auto-generated/>
        #nullable enable
        using BenchmarkDotNet.Columns;
        using BenchmarkDotNet.Reports;
        using BenchmarkDotNet.Running;

        namespace {1}
        {{
        {0}
        }}
        """;

        var sourceCode = string.Format(CultureInfo.InvariantCulture, sourceTemplate, columnsBuilder, benchmark.GeneratedNamespace);
        context.AddSource($"{benchmark.SafeBenchmarkTypeName}_Columns.g.cs", sourceCode);
    }

    public static void AddConfig(this SourceProductionContext context, BenchmarkTypeSpec benchmark, List<ReportColumnPropertySpec> columns)
    {
        const string columnInstanceTemplate = "            AddColumn(new {0}());";

        var columnsBuilder = new StringBuilder();

        foreach (var col in columns)
        {
            var columnTypeName = $"{col.SafeColumnTypeName}_Column";
            columnsBuilder.AppendLine(string.Format(CultureInfo.InvariantCulture, columnInstanceTemplate, columnTypeName));
        }

        var configTemplate =
        """
            public sealed class {0} : ManualConfig
            {{
                public {0}()
                {{
                    AddDiagnoser(new {1}());
        {2}
                }}
            }}

        """;

        var configBody = string.Format(
            CultureInfo.InvariantCulture,
            configTemplate,
            benchmark.ManualConfigTypeName,
            benchmark.InProcessDiagnoserTypeName,
            columnsBuilder.ToString().TrimEnd());

        var sourceTemplate =
        """
        // <auto-generated/>
        #nullable enable
        using BenchmarkDotNet.Configs;

        namespace {0}
        {{
        {1}
        }}
        """;

        var sourceCode = string.Format(
            CultureInfo.InvariantCulture, 
            sourceTemplate, 
            benchmark.GeneratedNamespace,
            configBody);
        
        context.AddSource($"{benchmark.SafeBenchmarkTypeName}_ManualConfig.g.cs", sourceCode);
    }

    public static void AddRegistrar(this SourceProductionContext context, BenchmarkTypeSpec benchmark)
    {
        var sourceTemplate =
        """
        // <auto-generated/>
        #nullable enable
        using BenchmarkDotNet.Attributes;
        using BenchmarkDotNet.Configs;
        using BenchmarkDotNet.ReportColumn.Generated;
        using {0};

        namespace {1}
        {{
            [Config(typeof({2}))]
            public partial class {3}
            {{
            }}
        }}
        """;

        var sourceCode = string.Format(
            CultureInfo.InvariantCulture,
            sourceTemplate,
            benchmark.GeneratedNamespace,
            benchmark.Namespace,
            benchmark.ManualConfigTypeName,
            benchmark.TypeName);

        context.AddSource($"{benchmark.SafeBenchmarkTypeName}_Registrar.g.cs", sourceCode);
    }
}
